<!DOCTYPE html>
<html lang="zh">

<head>
  <title>榔头男 - The Echo of Hammer</title>
  <meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
  <style>
    :root {
      --border-color: #291D4D;
      --dialog-background: #FFF3B4;
      --menu-background: #FFE8D2;
      --menu-border-color: #A48465;
      --menu-font-color: #3A160D;
      --menu-selected-background: #00000044;
    }

    * {
      box-sizing: border-box;
    }

    body {
      position: absolute;
      background: #333;
      padding: 0;
      margin: 0;
      top: 0px;
      left: 0px;
      right: 0px;
      bottom: 0px;
      overflow: hidden;
      font-family: 'Microsoft YaHei', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #1a1a1a 100%);
    }

    .game-container {
      position: relative;
      width: 800px;
      height: 500px;
      border: 4px solid #8b0000;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(139, 0, 0, 0.5);
    }

    .game-canvas {
      background: #000;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    .how-to-play {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      text-align: center;
      font-size: 15px;
      font-weight: bold;
      color: #fff;
      line-height: 50px;
      background-color: rgba(139, 0, 0, 0.8);
      margin: 0px;
      color: #fff;
      box-shadow: 0px 0px 5px #666;
      font-family: 'Microsoft YaHei', sans-serif;
    }

    .how-to-play .emp {
      color: #ffff00;
      font-weight: bold;
    }

    /* 文本消息样式 */
    .TextMessage {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 100px;
      background: var(--dialog-background);
      border-top: 3px solid var(--border-color);
      z-index: 2;
      padding: 12px;
    }

    .TextMessage_p {
      margin: 0;
      font-size: 18px;
      color: var(--menu-font-color);
      line-height: 22px;
    }

    .TextMessage_button {
      margin: 0;
      font-size: 16px;
      padding: 8px 12px;
      background: none;
      border: 2px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      margin-top: 8px;
    }

    .TextMessage_button:hover,
    .TextMessage_button:focus {
      background: var(--menu-selected-background);
    }

    /* 暂停菜单样式 */
    .PauseMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--menu-background);
      border: 3px solid var(--menu-border-color);
      border-radius: 8px;
      padding: 20px;
      z-index: 3;
      min-width: 200px;
    }

    .PauseMenu h2 {
      margin: 0 0 16px 0;
      color: var(--menu-font-color);
      text-align: center;
    }

    .PauseMenu button {
      display: block;
      width: 100%;
      margin: 8px 0;
      padding: 12px;
      background: none;
      border: 2px solid var(--menu-border-color);
      border-radius: 4px;
      color: var(--menu-font-color);
      cursor: pointer;
      font-size: 16px;
    }

    .PauseMenu button:hover,
    .PauseMenu button:focus {
      background: var(--menu-selected-background);
    }

    /* 场景过渡效果 */
    .SceneTransition {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background: #000;
      opacity: 0;
      z-index: 1;
      pointer-events: none;
    }

    .SceneTransition.fade-in {
      animation: fadeIn 800ms forwards;
    }

    .SceneTransition.fade-out {
      animation: fadeOut 400ms forwards;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
  </style>
</head>

<body>
  <div class="game-container">
    <canvas class="game-canvas" width="800" height="500"></canvas>
  </div>
  <p class="how-to-play">
    使用 <span class="emp">方向键</span> 移动角色。
    <span class="emp">空格键</span> 互动/对话。
    按 <span class="emp">ESC</span> 暂停游戏。
  </p>

  <script>
    // 工具函数
    const utils = {
      withGrid(n) {
        return n * 16;
      },
      asGridCoord(x, y) {
        return `${x * 16},${y * 16}`;
      },
      nextPosition(initialX, initialY, direction) {
        let x = initialX;
        let y = initialY;
        const size = 16;
        if (direction === "left") {
          x -= size;
        } else if (direction === "right") {
          x += size;
        } else if (direction === "up") {
          y -= size;
        } else if (direction === "down") {
          y += size;
        }
        return { x, y };
      },
      emitEvent(name, detail) {
        const event = new CustomEvent(name, {
          detail
        });
        document.dispatchEvent(event);
      }
    };

    // 键盘监听器
    class KeyPressListener {
      constructor(keyCode, callback) {
        let keySafe = true;
        this.keydownFunction = function(event) {
          if (event.code === keyCode) {
            if (keySafe) {
              keySafe = false;
              callback();
            }
          }
        };
        this.keyupFunction = function(event) {
          if (event.code === keyCode) {
            keySafe = true;
          }
        };
        document.addEventListener("keydown", this.keydownFunction);
        document.addEventListener("keyup", this.keyupFunction);
      }

      unbind() {
        document.removeEventListener("keydown", this.keydownFunction);
        document.removeEventListener("keyup", this.keyupFunction);
      }
    }

    // 方向输入处理
    class DirectionInput {
      constructor() {
        this.heldDirections = [];

        this.map = {
          "ArrowUp": "up",
          "KeyW": "up",
          "ArrowDown": "down",
          "KeyS": "down",
          "ArrowLeft": "left",
          "KeyA": "left",
          "ArrowRight": "right",
          "KeyD": "right",
        }
      }

      get direction() {
        return this.heldDirections[0];
      }

      init() {
        document.addEventListener("keydown", e => {
          const dir = this.map[e.code];
          if (dir && this.heldDirections.indexOf(dir) === -1) {
            this.heldDirections.unshift(dir);
          }
        });
        document.addEventListener("keyup", e => {
          const dir = this.map[e.code];
          const index = this.heldDirections.indexOf(dir);
          if (index > -1) {
            this.heldDirections.splice(index, 1);
          }
        });
      }
    }

    // 精灵类
    class Sprite {
      constructor(config) {
        this.image = new Image();
        this.image.src = config.src;
        this.image.onload = () => {
          this.isLoaded = true;
        }
        this.isLoaded = false;
        this.shadow = new Image();
        this.useShadow = config.useShadow || false;
        if (this.useShadow) {
          this.shadow.src = "./image in the game/character/shadow.png";
        }
        this.gameObject = config.gameObject;

        // 动画配置
        this.animations = config.animations || {
          "idle-down": [[0, 0]],
          "idle-right": [[0, 1]],
          "idle-up": [[0, 2]],
          "idle-left": [[0, 3]],
          "walk-down": [[1, 0], [0, 0], [3, 0], [0, 0]],
          "walk-right": [[1, 1], [0, 1], [3, 1], [0, 1]],
          "walk-up": [[1, 2], [0, 2], [3, 2], [0, 2]],
          "walk-left": [[1, 3], [0, 3], [3, 3], [0, 3]]
        };
        this.currentAnimation = config.currentAnimation || "idle-down";
        this.currentAnimationFrame = 0;

        this.animationFrameLimit = config.animationFrameLimit || 8;
        this.animationFrameProgress = this.animationFrameLimit;
      }

      get frame() {
        return this.animations[this.currentAnimation][this.currentAnimationFrame];
      }

      setAnimation(key) {
        if (this.currentAnimation !== key) {
          this.currentAnimation = key;
          this.currentAnimationFrame = 0;
          this.animationFrameProgress = this.animationFrameLimit;
        }
      }

      updateAnimationProgress() {
        if (this.animationFrameProgress > 0) {
          this.animationFrameProgress -= 1;
          return;
        }

        this.animationFrameProgress = this.animationFrameLimit;
        this.currentAnimationFrame += 1;

        if (this.frame === undefined) {
          this.currentAnimationFrame = 0;
        }
      }

      draw(ctx, cameraPerson) {
        const x = this.gameObject.x - 8 + utils.withGrid(8) - cameraPerson.x;
        const y = this.gameObject.y - 18 + utils.withGrid(5) - cameraPerson.y;

        this.isShadow && ctx.drawImage(this.shadow, x, y);

        const [frameX, frameY] = this.frame;

        this.isLoaded && ctx.drawImage(this.image,
          frameX * 32, frameY * 32,
          32, 32,
          x, y,
          32, 32
        );

        this.updateAnimationProgress();
      }
    }

    // 游戏对象基类
    class GameObject {
      constructor(config) {
        this.id = null;
        this.isMounted = false;
        this.x = config.x || 0;
        this.y = config.y || 0;
        this.direction = config.direction || "down";
        this.sprite = new Sprite({
          gameObject: this,
          src: config.src || "./image in the game/character/侦探.png",
          useShadow: config.useShadow,
        });

        this.behaviorLoop = config.behaviorLoop || [];
        this.behaviorLoopIndex = 0;
        this.talking = config.talking || [];
      }

      mount(map) {
        this.isMounted = true;
        setTimeout(() => {
          this.doBehaviorEvent(map);
        }, 10);
      }

      update() {
        // 基类更新方法
      }

      async doBehaviorEvent(map) {
        if (this.behaviorLoop.length === 0) {
          return;
        }

        if (map.isCutscenePlaying) {
          setTimeout(() => {
            this.doBehaviorEvent(map);
          }, 1000);
          return;
        }

        let eventConfig = this.behaviorLoop[this.behaviorLoopIndex];
        eventConfig.who = this.id;

        const eventHandler = new OverworldEvent({ event: eventConfig, map });
        await eventHandler.init();

        this.behaviorLoopIndex += 1;
        if (this.behaviorLoopIndex === this.behaviorLoop.length) {
          this.behaviorLoopIndex = 0;
        }

        this.doBehaviorEvent(map);
      }
    }

    // 人物类
    class Person extends GameObject {
      constructor(config) {
        super(config);
        this.movingProgressRemaining = 0;
        this.isStanding = false;
        this.intentPosition = null;

        this.isPlayerControlled = config.isPlayerControlled || false;

        this.directionUpdate = {
          "up": ["y", -2],
          "down": ["y", 2],
          "left": ["x", -2],
          "right": ["x", 2],
        };
      }

      update(state) {
        if (this.movingProgressRemaining > 0) {
          this.updatePosition();
        } else {
          if (!state.map.isCutscenePlaying && this.isPlayerControlled && state.arrow) {
            this.startBehavior(state, {
              type: "walk",
              direction: state.arrow
            });
          }
          this.updateSprite(state);
        }
      }

      startBehavior(state, behavior) {
        if (!this.isMounted) {
          return;
        }

        this.direction = behavior.direction;

        if (behavior.type === "walk") {
          if (state.map.isSpaceTaken(this.x, this.y, this.direction)) {
            behavior.retry && setTimeout(() => {
              this.startBehavior(state, behavior);
            }, 10);
            return;
          }

          this.movingProgressRemaining = 32;

          const intentPosition = utils.nextPosition(this.x, this.y, this.direction);
          this.intentPosition = [intentPosition.x, intentPosition.y];

          this.updateSprite(state);
        }

        if (behavior.type === "stand") {
          this.isStanding = true;
          setTimeout(() => {
            utils.emitEvent("PersonStandComplete", {
              whoId: this.id
            });
            this.isStanding = false;
          }, behavior.time);
        }
      }

      updatePosition() {
        const [property, change] = this.directionUpdate[this.direction];
        this[property] += change;
        this.movingProgressRemaining -= 2;

        if (this.movingProgressRemaining === 0) {
          this.intentPosition = null;
          utils.emitEvent("PersonWalkingComplete", {
            whoId: this.id
          });
        }
      }

      updateSprite() {
        if (this.movingProgressRemaining > 0) {
          this.sprite.setAnimation("walk-" + this.direction);
          return;
        }
        this.sprite.setAnimation("idle-" + this.direction);
      }
    }

    // 文本消息类
    class TextMessage {
      constructor({ text, onComplete }) {
        this.text = text;
        this.onComplete = onComplete;
        this.element = null;
      }

      createElement() {
        this.element = document.createElement("div");
        this.element.classList.add("TextMessage");

        this.element.innerHTML = (`
          <p class="TextMessage_p">${this.text}</p>
          <button class="TextMessage_button">继续</button>
        `);

        this.element.querySelector("button").addEventListener("click", () => {
          this.done();
        });

        this.actionListener = new KeyPressListener("Space", () => {
          this.done();
        });
      }

      done() {
        if (this.revealingText.isDone) {
          this.element.remove();
          this.actionListener.unbind();
          this.onComplete();
        } else {
          this.revealingText.warpToDone();
        }
      }

      init(container) {
        return new Promise(resolve => {
          this.onComplete = resolve;
          this.createElement();
          container.appendChild(this.element);
          this.revealingText = new RevealingText({
            element: this.element.querySelector(".TextMessage_p"),
            text: this.text
          });
        });
      }
    }

    // 文字逐渐显示效果
    class RevealingText {
      constructor(config) {
        this.element = config.element;
        this.text = config.text;
        this.speed = config.speed || 60;

        this.timeout = null;
        this.isDone = false;
      }

      revealOneCharacter(list) {
        const next = list.splice(0, 1)[0];
        next.span.classList.add("revealed");

        if (list.length > 0) {
          this.timeout = setTimeout(() => {
            this.revealOneCharacter(list);
          }, next.delayAfter);
        } else {
          this.isDone = true;
        }
      }

      warpToDone() {
        clearTimeout(this.timeout);
        this.isDone = true;
        this.element.querySelectorAll(".RevealingText_span").forEach(s => {
          s.classList.add("revealed");
        });
      }

      init() {
        let characters = [];
        this.text.split("").forEach(character => {
          let span = document.createElement("span");
          span.classList.add("RevealingText_span");
          span.textContent = character;
          this.element.appendChild(span);

          characters.push({
            span,
            delayAfter: character === " " ? 0 : this.speed
          });
        });

        this.revealOneCharacter(characters);
      }
    }

    // 场景过渡效果
    class SceneTransition {
      constructor() {
        this.element = null;
      }

      createElement() {
        this.element = document.createElement("div");
        this.element.classList.add("SceneTransition");
      }

      fadeOut() {
        this.element.classList.add("fade-out");
        this.element.addEventListener("animationend", () => {
          this.element.remove();
        }, { once: true });
      }

      init(container, callback) {
        this.createElement();
        container.appendChild(this.element);
        this.element.classList.add("fade-in");
        this.element.addEventListener("animationend", () => {
          callback();
          this.fadeOut();
        }, { once: true });
      }
    }

    // 暂停菜单
    class PauseMenu {
      constructor({ onComplete }) {
        this.onComplete = onComplete;
      }

      createElement() {
        this.element = document.createElement("div");
        this.element.classList.add("PauseMenu");
        this.element.innerHTML = (`
          <h2>游戏暂停</h2>
          <button data-button="resume">继续游戏</button>
          <button data-button="save">保存游戏</button>
          <button data-button="load">加载游戏</button>
          <button data-button="title">返回标题</button>
        `);
      }

      close() {
        this.element.remove();
        this.onComplete();
      }

      init(container) {
        return new Promise(resolve => {
          this.onComplete = resolve;
          this.createElement();
          container.appendChild(this.element);

          this.element.addEventListener("click", (e) => {
            if (e.target.matches("[data-button]")) {
              const button = e.target.getAttribute("data-button");
              if (button === "resume") {
                this.close();
              } else if (button === "save") {
                alert("保存功能待实现");
              } else if (button === "load") {
                alert("加载功能待实现");
              } else if (button === "title") {
                window.location.reload();
              }
            }
          });
        });
      }
    }

    // 世界事件处理
    class OverworldEvent {
      constructor({ map, event }) {
        this.map = map;
        this.event = event;
      }

      stand(resolve) {
        const who = this.map.gameObjects[this.event.who];
        who.startBehavior({
          map: this.map
        }, {
          type: "stand",
          direction: this.event.direction,
          time: this.event.time
        });

        const completeHandler = e => {
          if (e.detail.whoId === this.event.who) {
            document.removeEventListener("PersonStandComplete", completeHandler);
            resolve();
          }
        };
        document.addEventListener("PersonStandComplete", completeHandler);
      }

      walk(resolve) {
        const who = this.map.gameObjects[this.event.who];
        who.startBehavior({
          map: this.map
        }, {
          type: "walk",
          direction: this.event.direction,
          retry: true
        });

        const completeHandler = e => {
          if (e.detail.whoId === this.event.who) {
            document.removeEventListener("PersonWalkingComplete", completeHandler);
            resolve();
          }
        };
        document.addEventListener("PersonWalkingComplete", completeHandler);
      }

      textMessage(resolve) {
        if (this.event.faceHero) {
          const obj = this.map.gameObjects[this.event.faceHero];
          obj.direction = utils.oppositeDirection(this.map.gameObjects["hero"].direction);
        }

        const message = new TextMessage({
          text: this.event.text,
          onComplete: () => resolve()
        });
        message.init(document.querySelector(".game-container"));
      }

      changeMap(resolve) {
        const sceneTransition = new SceneTransition();
        sceneTransition.init(document.querySelector(".game-container"), () => {
          this.map.overworld.startMap(window.OverworldMaps[this.event.map], {
            x: this.event.x,
            y: this.event.y,
            direction: this.event.direction,
          });
          resolve();

          setTimeout(() => {
            this.map.overworld.startGameLoop();
          }, 300);
        });
      }

      pause(resolve) {
        this.map.isPaused = true;
        const menu = new PauseMenu({
          onComplete: () => {
            resolve();
            this.map.isPaused = false;
            this.map.overworld.startGameLoop();
          }
        });
        menu.init(document.querySelector(".game-container"));
      }

      init() {
        return new Promise(resolve => {
          this[this.event.type](resolve);
        });
      }
    }

    // 地图类
    class OverworldMap {
      constructor(config) {
        this.overworld = null;
        this.gameObjects = {};
        this.configObjects = config.configObjects;

        this.cutsceneSpaces = config.cutsceneSpaces || {};
        this.walls = config.walls || {};

        this.lowerImage = new Image();
        this.lowerImage.src = config.lowerSrc;

        this.upperImage = new Image();
        this.upperImage.src = config.upperSrc;

        this.isCutscenePlaying = false;
        this.isPaused = false;
      }

      drawLowerImage(ctx, cameraPerson) {
        ctx.drawImage(
          this.lowerImage,
          utils.withGrid(8) - cameraPerson.x,
          utils.withGrid(5) - cameraPerson.y
        );
      }

      drawUpperImage(ctx, cameraPerson) {
        ctx.drawImage(
          this.upperImage,
          utils.withGrid(8) - cameraPerson.x,
          utils.withGrid(5) - cameraPerson.y
        );
      }

      isSpaceTaken(currentX, currentY, direction) {
        let { x, y } = utils.nextPosition(currentX, currentY, direction);
        if (this.walls[`${x},${y}`]) {
          return true;
        }
        return Object.values(this.gameObjects).find(obj => {
          if (obj.x === x && obj.y === y) { return true; }
          if (obj.intentPosition && obj.intentPosition[0] === x && obj.intentPosition[1] === y) {
            return true;
          }
          return false;
        });
      }

      mountObjects() {
        Object.keys(this.configObjects).forEach(key => {
          let object = this.configObjects[key];
          object.id = key;

          let instance;
          if (object.type === "Person") {
            instance = new Person(object);
          }
          this.gameObjects[key] = instance;
          this.gameObjects[key].id = key;
          instance.mount(this);
        });
      }

      async startCutscene(events) {
        this.isCutscenePlaying = true;

        for (let i = 0; i < events.length; i++) {
          const eventHandler = new OverworldEvent({
            event: events[i],
            map: this,
          });
          await eventHandler.init();
        }
        this.isCutscenePlaying = false;
      }

      checkForActionCutscene() {
        const hero = this.gameObjects["hero"];
        const nextCoords = utils.nextPosition(hero.x, hero.y, hero.direction);
        const match = Object.values(this.gameObjects).find(object => {
          return `${object.x},${object.y}` === `${nextCoords.x},${nextCoords.y}`;
        });
        if (!this.isCutscenePlaying && match && match.talking.length) {
          this.startCutscene(match.talking[0].events);
        }
      }

      checkForFootstepCutscene() {
        const hero = this.gameObjects["hero"];
        const match = this.cutsceneSpaces[`${hero.x},${hero.y}`];
        if (!this.isCutscenePlaying && match) {
          this.startCutscene(match[0].events);
        }
      }
    }

    // 主游戏世界类
    class Overworld {
      constructor(config) {
        this.element = config.element;
        this.canvas = this.element.querySelector(".game-canvas");
        this.ctx = this.canvas.getContext("2d");
        this.map = null;
      }

      startGameLoop() {
        const step = () => {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          const cameraPerson = this.map.gameObjects.hero;

          Object.values(this.map.gameObjects).forEach(object => {
            object.update({
              arrow: this.directionInput.direction,
              map: this.map,
            });
          });

          this.map.drawLowerImage(this.ctx, cameraPerson);

          Object.values(this.map.gameObjects).sort((a, b) => {
            return a.y - b.y;
          }).forEach(object => {
            object.sprite.draw(this.ctx, cameraPerson);
          });

          this.map.drawUpperImage(this.ctx, cameraPerson);

          if (!this.map.isPaused) {
            requestAnimationFrame(() => {
              step();
            });
          }
        };
        step();
      }

      bindActionInput() {
        this.enter = new KeyPressListener("Space", () => {
          this.map.checkForActionCutscene();
        });
        this.esc = new KeyPressListener("Escape", () => {
          if (!this.map.isCutscenePlaying) {
            this.map.startCutscene([
              { type: "pause" }
            ]);
          }
        });
      }

      bindHeroPositionCheck() {
        document.addEventListener("PersonWalkingComplete", e => {
          if (e.detail.whoId === "hero") {
            this.map.checkForFootstepCutscene();
          }
        });
      }

      startMap(mapConfig, heroInitialState = null) {
        this.map = new OverworldMap(mapConfig);
        this.map.overworld = this;
        this.map.mountObjects();

        if (heroInitialState) {
          const { hero } = this.map.gameObjects;
          hero.x = heroInitialState.x;
          hero.y = heroInitialState.y;
          hero.direction = heroInitialState.direction;
        }
      }

      async init() {
        this.startMap(window.OverworldMaps.LivingRoom);

        this.bindActionInput();
        this.bindHeroPositionCheck();

        this.directionInput = new DirectionInput();
        this.directionInput.init();

        this.startGameLoop();
      }
    }

    // 地图配置
    window.OverworldMaps = {
      LivingRoom: {
        id: "LivingRoom",
        lowerSrc: "./image in the game/map/客厅.png",
        upperSrc: "./image in the game/map/客厅.png", // 如果没有上层图像，使用相同的
        configObjects: {
          hero: {
            type: "Person",
            isPlayerControlled: true,
            x: utils.withGrid(5),
            y: utils.withGrid(6),
            src: "./image in the game/character/侦探.png",
            useShadow: true,
          },
          npc1: {
            type: "Person",
            x: utils.withGrid(8),
            y: utils.withGrid(4),
            src: "./image in the game/character/wx警官.png",
            talking: [
              {
                events: [
                  { type: "textMessage", text: "你好，我是王警官。这里发生了一起案件。", faceHero: "npc1" },
                  { type: "textMessage", text: "作为侦探，你需要仔细调查现场。" },
                ]
              }
            ]
          },
          npc2: {
            type: "Person",
            x: utils.withGrid(3),
            y: utils.withGrid(8),
            src: "./image in the game/character/花生.png",
            talking: [
              {
                events: [
                  { type: "textMessage", text: "我是目击者花生，我看到了一些可疑的事情...", faceHero: "npc2" },
                ]
              }
            ]
          }
        },
        walls: {
          [utils.asGridCoord(0, 4)]: true,
          [utils.asGridCoord(0, 5)]: true,
          [utils.asGridCoord(0, 6)]: true,
          [utils.asGridCoord(0, 7)]: true,
          [utils.asGridCoord(0, 8)]: true,
          [utils.asGridCoord(0, 9)]: true,
          [utils.asGridCoord(1, 3)]: true,
          [utils.asGridCoord(2, 3)]: true,
          [utils.asGridCoord(3, 3)]: true,
          [utils.asGridCoord(4, 3)]: true,
          [utils.asGridCoord(6, 3)]: true,
          [utils.asGridCoord(7, 3)]: true,
          [utils.asGridCoord(8, 3)]: true,
          [utils.asGridCoord(9, 3)]: true,
          [utils.asGridCoord(10, 4)]: true,
          [utils.asGridCoord(10, 5)]: true,
          [utils.asGridCoord(10, 6)]: true,
          [utils.asGridCoord(10, 7)]: true,
          [utils.asGridCoord(10, 8)]: true,
          [utils.asGridCoord(10, 9)]: true,
          [utils.asGridCoord(1, 10)]: true,
          [utils.asGridCoord(2, 10)]: true,
          [utils.asGridCoord(3, 10)]: true,
          [utils.asGridCoord(4, 10)]: true,
          [utils.asGridCoord(5, 10)]: true,
          [utils.asGridCoord(6, 10)]: true,
          [utils.asGridCoord(7, 10)]: true,
          [utils.asGridCoord(8, 10)]: true,
          [utils.asGridCoord(9, 10)]: true,
        },
        cutsceneSpaces: {
          [utils.asGridCoord(5, 3)]: [
            {
              events: [
                { type: "changeMap", map: "Bedroom", x: utils.withGrid(5), y: utils.withGrid(9), direction: "up" }
              ]
            }
          ]
        }
      },
      Bedroom: {
        id: "Bedroom",
        lowerSrc: "./image in the game/map/卧室.png",
        upperSrc: "./image in the game/map/卧室.png",
        configObjects: {
          hero: {
            type: "Person",
            isPlayerControlled: true,
            x: utils.withGrid(5),
            y: utils.withGrid(9),
            src: "./image in the game/character/侦探.png",
            useShadow: true,
          },
          suspect: {
            type: "Person",
            x: utils.withGrid(7),
            y: utils.withGrid(5),
            src: "./image in the game/character/送货员.png",
            talking: [
              {
                events: [
                  { type: "textMessage", text: "我是嫌疑人，但我是无辜的！", faceHero: "suspect" },
                  { type: "textMessage", text: "请相信我，我没有做任何坏事。" },
                ]
              }
            ]
          }
        },
        walls: {
          [utils.asGridCoord(0, 4)]: true,
          [utils.asGridCoord(0, 5)]: true,
          [utils.asGridCoord(0, 6)]: true,
          [utils.asGridCoord(0, 7)]: true,
          [utils.asGridCoord(0, 8)]: true,
          [utils.asGridCoord(1, 3)]: true,
          [utils.asGridCoord(2, 3)]: true,
          [utils.asGridCoord(3, 3)]: true,
          [utils.asGridCoord(4, 3)]: true,
          [utils.asGridCoord(6, 3)]: true,
          [utils.asGridCoord(7, 3)]: true,
          [utils.asGridCoord(8, 3)]: true,
          [utils.asGridCoード(9, 3)]: true,
          [utils.asGridCoord(10, 4)]: true,
          [utils.asGridCoord(10, 5)]: true,
          [utils.asGridCoord(10, 6)]: true,
          [utils.asGridCoord(10, 7)]: true,
          [utils.asGridCoord(10, 8)]: true,
        },
        cutsceneSpaces: {
          [utils.asGridCoord(5, 10)]: [
            {
              events: [
                { type: "changeMap", map: "LivingRoom", x: utils.withGrid(5), y: utils.withGrid(4), direction: "down" }
              ]
            }
          ]
        }
      }
    };

    // 游戏初始化
    (function () {
      const overworld = new Overworld({
        element: document.querySelector(".game-container")
      });
      window.overworld = overworld;
      overworld.init();
    })();
  </script>
</body>

</html>